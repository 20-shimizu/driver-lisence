/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * FastAPI Sample
 * OpenAPI spec version: 0.0.1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'

const api = axios.create({
  baseURL: 'http://localhost:8000',
});

export type GetFamiliesByUserIdFamiliesUsersUserIdGet200 = FamilyResponse[] | null;

export type GetInfoGet200 = {[key: string]: string};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface UserResponse {
  /**
   * „É¶„Éº„Ç∂„ÉºÂêç(50ÊñáÂ≠ó‰ª•‰∏ã)
   * @maxLength 50
   */
  userName: string;
  /**
   * Âπ¥ÈΩ¢(18Ê≠≥‰ª•‰∏ä100Ê≠≥‰ª•‰∏ã)
   * @minimum 18
   * @maximum 100
   */
  age: number;
  user_id: number;
}

export interface UserCreate {
  /**
   * „É¶„Éº„Ç∂„ÉºÂêç(50ÊñáÂ≠ó‰ª•‰∏ã)
   * @maxLength 50
   */
  userName: string;
  /**
   * Âπ¥ÈΩ¢(18Ê≠≥‰ª•‰∏ä100Ê≠≥‰ª•‰∏ã)
   * @minimum 18
   * @maximum 100
   */
  age: number;
  /**
   * „Éë„Çπ„ÉØ„Éº„Éâ(8ÊñáÂ≠ó‰ª•‰∏ä)
   * @minLength 8
   */
  password: string;
}

export interface Token {
  access_token: string;
  token_type: string;
}

export interface SensorResponse {
  userId: number;
  startedAt: string;
  endedAt: string;
  /** @minimum 0 */
  milage: number;
  /** @minimum 0 */
  averageSpeed: number;
  /** @minimum 0 */
  journeyTime: number;
  /** @minimum 0 */
  longestContinuousDrive: number;
  /** @minimum 0 */
  idlingTime: number;
  /** @minimum 0 */
  maxSpeed: number;
  /** @minimum 0 */
  acceralationCount: number;
  /** @minimum 0 */
  brakingCount: number;
  /** @minimum 0 */
  corneringCount: number;
  sensorId: number;
}

export interface SensorBase {
  userId: number;
  startedAt: string;
  endedAt: string;
  /** @minimum 0 */
  milage: number;
  /** @minimum 0 */
  averageSpeed: number;
  /** @minimum 0 */
  journeyTime: number;
  /** @minimum 0 */
  longestContinuousDrive: number;
  /** @minimum 0 */
  idlingTime: number;
  /** @minimum 0 */
  maxSpeed: number;
  /** @minimum 0 */
  acceralationCount: number;
  /** @minimum 0 */
  brakingCount: number;
  /** @minimum 0 */
  corneringCount: number;
}

/**
 * „Ç≥„Éº„Éä„É™„É≥„Ç∞„Å´Èñ¢„Åô„Çã„Ç≥„É°„É≥„Éà
 */
export type ReportResponseCorneringComment = string | null;

/**
 * „Éñ„É¨„Éº„Ç≠„Å´Èñ¢„Åô„Çã„Ç≥„É°„É≥„Éà
 */
export type ReportResponseBrakingComment = string | null;

/**
 * Âä†ÈÄü„Å´Èñ¢„Åô„Çã„Ç≥„É°„É≥„Éà
 */
export type ReportResponseAcceralationComment = string | null;

/**
 * „É¨„Éù„Éº„Éà„ÅÆÂÖ®‰ΩìÁöÑ„Å™Ê¶ÇË¶Å
 */
export type ReportResponseOverallSummary = string | null;

export type ReportEvaluationStatus = typeof ReportEvaluationStatus[keyof typeof ReportEvaluationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportEvaluationStatus = {
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export type ReportDrivingType = typeof ReportDrivingType[keyof typeof ReportDrivingType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportDrivingType = {
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_3: 3,
  NUMBER_4: 4,
  NUMBER_5: 5,
} as const;

export interface ReportResponse {
  /** „É¶„Éº„Ç∂„ÉºID */
  userId: number;
  /** „Çª„É≥„Çµ„ÉºID */
  sensorId: number;
  /** ÈÅãËª¢„Çø„Ç§„ÉóÔºàENUM„ÅÆÂÄôË£úÔºâ */
  drivingType: ReportDrivingType;
  /** Ë©ï‰æ°„Çπ„ÉÜ„Éº„Çø„ÇπÔºàENUM„ÅÆÂÄôË£úÔºâ */
  evaluationStatus: ReportEvaluationStatus;
  /** „É¨„Éù„Éº„Éà„ÅÆÂÖ®‰ΩìÁöÑ„Å™Ê¶ÇË¶Å */
  overallSummary?: ReportResponseOverallSummary;
  /** Âä†ÈÄü„Å´Èñ¢„Åô„Çã„Ç≥„É°„É≥„Éà */
  acceralationComment?: ReportResponseAcceralationComment;
  /** „Éñ„É¨„Éº„Ç≠„Å´Èñ¢„Åô„Çã„Ç≥„É°„É≥„Éà */
  brakingComment?: ReportResponseBrakingComment;
  /** „Ç≥„Éº„Éä„É™„É≥„Ç∞„Å´Èñ¢„Åô„Çã„Ç≥„É°„É≥„Éà */
  corneringComment?: ReportResponseCorneringComment;
  reportId: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface FamilyUpdate {
  /**
   * ÂÆ∂Êóè„ÉªÈñ¢‰øÇËÄÖÂêç(50ÊñáÂ≠ó‰ª•‰∏ã)
   * @maxLength 50
   */
  familyName: string;
  /**
   * „É°„Éº„É´„Ç¢„Éâ„É¨„Çπ(50ÊñáÂ≠ó‰ª•ÂÜÖ)
   * @maxLength 50
   */
  email: string;
}

export interface FamilyResponse {
  /**
   * ÂÆ∂Êóè„ÉªÈñ¢‰øÇËÄÖÂêç(50ÊñáÂ≠ó‰ª•‰∏ã)
   * @maxLength 50
   */
  familyName: string;
  /**
   * „É°„Éº„É´„Ç¢„Éâ„É¨„Çπ(50ÊñáÂ≠ó‰ª•ÂÜÖ)
   * @maxLength 50
   */
  email: string;
  family_id: number;
}

export interface FamilyCreate {
  /**
   * ÂÆ∂Êóè„ÉªÈñ¢‰øÇËÄÖÂêç(50ÊñáÂ≠ó‰ª•‰∏ã)
   * @maxLength 50
   */
  familyName: string;
  /**
   * „É°„Éº„É´„Ç¢„Éâ„É¨„Çπ(50ÊñáÂ≠ó‰ª•ÂÜÖ)
   * @maxLength 50
   */
  email: string;
  /** „É¶„Éº„Ç∂„ÉºID */
  userId: number;
}

export type EmailSendAttachment = string | null;

export interface EmailSend {
  to: string[];
  /** @maxLength 100 */
  subject: string;
  body: string;
  attachment?: EmailSendAttachment;
}

export type BodyLoginAccessTokenAuthLoginPostClientSecret = string | null;

export type BodyLoginAccessTokenAuthLoginPostClientId = string | null;

export type BodyLoginAccessTokenAuthLoginPostGrantType = string | null;

export interface BodyLoginAccessTokenAuthLoginPost {
  grant_type?: BodyLoginAccessTokenAuthLoginPostGrantType;
  username: string;
  password: string;
  scope?: string;
  client_id?: BodyLoginAccessTokenAuthLoginPostClientId;
  client_secret?: BodyLoginAccessTokenAuthLoginPostClientSecret;
}



type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;



/**
 * @summary Get Info
 */
export const getInfoGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetInfoGet200>> => {
    
    
    return api.get(
      `/`,options
    );
  }


export const getGetInfoGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getGetInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof getInfoGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInfoGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInfoGet>>> = ({ signal }) => getInfoGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInfoGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof getInfoGet>>>
export type GetInfoGetQueryError = AxiosError<unknown>


/**
 * @summary Get Info
 */

export function useGetInfoGet<TData = Awaited<ReturnType<typeof getInfoGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetInfoGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * OAuth2 compatible token login, get an access token for future requests.
 * @summary Login Access Token
 */
export const loginAccessTokenAuthLoginPost = (
    bodyLoginAccessTokenAuthLoginPost: BodyLoginAccessTokenAuthLoginPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Token>> => {
    
    const formUrlEncoded = new URLSearchParams();
if(bodyLoginAccessTokenAuthLoginPost.grant_type !== undefined && bodyLoginAccessTokenAuthLoginPost.grant_type !== null) {
 formUrlEncoded.append('grant_type', bodyLoginAccessTokenAuthLoginPost.grant_type)
 }
formUrlEncoded.append('username', bodyLoginAccessTokenAuthLoginPost.username)
formUrlEncoded.append('password', bodyLoginAccessTokenAuthLoginPost.password)
if(bodyLoginAccessTokenAuthLoginPost.scope !== undefined) {
 formUrlEncoded.append('scope', bodyLoginAccessTokenAuthLoginPost.scope)
 }
if(bodyLoginAccessTokenAuthLoginPost.client_id !== undefined && bodyLoginAccessTokenAuthLoginPost.client_id !== null) {
 formUrlEncoded.append('client_id', bodyLoginAccessTokenAuthLoginPost.client_id)
 }
if(bodyLoginAccessTokenAuthLoginPost.client_secret !== undefined && bodyLoginAccessTokenAuthLoginPost.client_secret !== null) {
 formUrlEncoded.append('client_secret', bodyLoginAccessTokenAuthLoginPost.client_secret)
 }

    return api.post(
      `/auth/login`,
      formUrlEncoded,options
    );
  }



export const getLoginAccessTokenAuthLoginPostMutationOptions = <TData = Awaited<ReturnType<typeof loginAccessTokenAuthLoginPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyLoginAccessTokenAuthLoginPost}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['loginAccessTokenAuthLoginPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginAccessTokenAuthLoginPost>>, {data: BodyLoginAccessTokenAuthLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  loginAccessTokenAuthLoginPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyLoginAccessTokenAuthLoginPost}, TContext>}

    export type LoginAccessTokenAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginAccessTokenAuthLoginPost>>>
    export type LoginAccessTokenAuthLoginPostMutationBody = BodyLoginAccessTokenAuthLoginPost
    export type LoginAccessTokenAuthLoginPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Login Access Token
 */
export const useLoginAccessTokenAuthLoginPost = <TData = Awaited<ReturnType<typeof loginAccessTokenAuthLoginPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyLoginAccessTokenAuthLoginPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: BodyLoginAccessTokenAuthLoginPost},
        TContext
      > => {

      const mutationOptions = getLoginAccessTokenAuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Users
 */
export const getUsersUsersGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse[]>> => {
    
    
    return api.get(
      `/users`,options
    );
  }


export const getGetUsersUsersGetQueryKey = () => {
    return [`/users`] as const;
    }

    
export const getGetUsersUsersGetQueryOptions = <TData = Awaited<ReturnType<typeof getUsersUsersGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersUsersGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersUsersGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersUsersGet>>> = ({ signal }) => getUsersUsersGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersUsersGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersUsersGet>>>
export type GetUsersUsersGetQueryError = AxiosError<unknown>


/**
 * @summary Get Users
 */

export function useGetUsersUsersGet<TData = Awaited<ReturnType<typeof getUsersUsersGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersUsersGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersUsersGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get User Me
 */
export const getUserMeUsersMeGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return api.get(
      `/users/me`,options
    );
  }


export const getGetUserMeUsersMeGetQueryKey = () => {
    return [`/users/me`] as const;
    }

    
export const getGetUserMeUsersMeGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserMeUsersMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserMeUsersMeGet>>> = ({ signal }) => getUserMeUsersMeGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserMeUsersMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserMeUsersMeGet>>>
export type GetUserMeUsersMeGetQueryError = AxiosError<unknown>


/**
 * @summary Get User Me
 */

export function useGetUserMeUsersMeGet<TData = Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserMeUsersMeGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get User
 */
export const getUserUsersIdGet = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return api.get(
      `/users/${id}`,options
    );
  }


export const getGetUserUsersIdGetQueryKey = (id: number,) => {
    return [`/users/${id}`] as const;
    }

    
export const getGetUserUsersIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserUsersIdGet>>, TError = AxiosError<HTTPValidationError>>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserUsersIdGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserUsersIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserUsersIdGet>>> = ({ signal }) => getUserUsersIdGet(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserUsersIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserUsersIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserUsersIdGet>>>
export type GetUserUsersIdGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get User
 */

export function useGetUserUsersIdGet<TData = Awaited<ReturnType<typeof getUserUsersIdGet>>, TError = AxiosError<HTTPValidationError>>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserUsersIdGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserUsersIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create User
 */
export const createUserUsersRegisterPost = (
    userCreate: UserCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return api.post(
      `/users/register`,
      userCreate,options
    );
  }



export const getCreateUserUsersRegisterPostMutationOptions = <TData = Awaited<ReturnType<typeof createUserUsersRegisterPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: UserCreate}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['createUserUsersRegisterPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserUsersRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  createUserUsersRegisterPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: UserCreate}, TContext>}

    export type CreateUserUsersRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof createUserUsersRegisterPost>>>
    export type CreateUserUsersRegisterPostMutationBody = UserCreate
    export type CreateUserUsersRegisterPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create User
 */
export const useCreateUserUsersRegisterPost = <TData = Awaited<ReturnType<typeof createUserUsersRegisterPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: UserCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getCreateUserUsersRegisterPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Families By User Id
 */
export const getFamiliesByUserIdFamiliesUsersUserIdGet = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetFamiliesByUserIdFamiliesUsersUserIdGet200>> => {
    
    
    return api.get(
      `/families/users/${userId}`,options
    );
  }


export const getGetFamiliesByUserIdFamiliesUsersUserIdGetQueryKey = (userId: number,) => {
    return [`/families/users/${userId}`] as const;
    }

    
export const getGetFamiliesByUserIdFamiliesUsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getFamiliesByUserIdFamiliesUsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(userId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFamiliesByUserIdFamiliesUsersUserIdGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFamiliesByUserIdFamiliesUsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFamiliesByUserIdFamiliesUsersUserIdGet>>> = ({ signal }) => getFamiliesByUserIdFamiliesUsersUserIdGet(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFamiliesByUserIdFamiliesUsersUserIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetFamiliesByUserIdFamiliesUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getFamiliesByUserIdFamiliesUsersUserIdGet>>>
export type GetFamiliesByUserIdFamiliesUsersUserIdGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Families By User Id
 */

export function useGetFamiliesByUserIdFamiliesUsersUserIdGet<TData = Awaited<ReturnType<typeof getFamiliesByUserIdFamiliesUsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(
 userId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFamiliesByUserIdFamiliesUsersUserIdGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetFamiliesByUserIdFamiliesUsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Family
 */
export const getFamilyFamiliesIdGet = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FamilyResponse>> => {
    
    
    return api.get(
      `/families/${id}`,options
    );
  }


export const getGetFamilyFamiliesIdGetQueryKey = (id: number,) => {
    return [`/families/${id}`] as const;
    }

    
export const getGetFamilyFamiliesIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getFamilyFamiliesIdGet>>, TError = AxiosError<HTTPValidationError>>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFamilyFamiliesIdGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFamilyFamiliesIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFamilyFamiliesIdGet>>> = ({ signal }) => getFamilyFamiliesIdGet(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFamilyFamiliesIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetFamilyFamiliesIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getFamilyFamiliesIdGet>>>
export type GetFamilyFamiliesIdGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Family
 */

export function useGetFamilyFamiliesIdGet<TData = Awaited<ReturnType<typeof getFamilyFamiliesIdGet>>, TError = AxiosError<HTTPValidationError>>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFamilyFamiliesIdGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetFamilyFamiliesIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Family
 */
export const updateFamilyFamiliesIdPut = (
    id: number,
    familyUpdate: FamilyUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FamilyResponse>> => {
    
    
    return api.put(
      `/families/${id}`,
      familyUpdate,options
    );
  }



export const getUpdateFamilyFamiliesIdPutMutationOptions = <TData = Awaited<ReturnType<typeof updateFamilyFamiliesIdPut>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FamilyUpdate}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateFamilyFamiliesIdPut'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFamilyFamiliesIdPut>>, {id: number;data: FamilyUpdate}> = (props) => {
          const {id,data} = props ?? {};

          return  updateFamilyFamiliesIdPut(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FamilyUpdate}, TContext>}

    export type UpdateFamilyFamiliesIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateFamilyFamiliesIdPut>>>
    export type UpdateFamilyFamiliesIdPutMutationBody = FamilyUpdate
    export type UpdateFamilyFamiliesIdPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Family
 */
export const useUpdateFamilyFamiliesIdPut = <TData = Awaited<ReturnType<typeof updateFamilyFamiliesIdPut>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FamilyUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FamilyUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateFamilyFamiliesIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Family
 */
export const deleteFamilyFamiliesIdDelete = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return api.delete(
      `/families/${id}`,options
    );
  }



export const getDeleteFamilyFamiliesIdDeleteMutationOptions = <TData = Awaited<ReturnType<typeof deleteFamilyFamiliesIdDelete>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteFamilyFamiliesIdDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFamilyFamiliesIdDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteFamilyFamiliesIdDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteFamilyFamiliesIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFamilyFamiliesIdDelete>>>
    
    export type DeleteFamilyFamiliesIdDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Family
 */
export const useDeleteFamilyFamiliesIdDelete = <TData = Awaited<ReturnType<typeof deleteFamilyFamiliesIdDelete>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteFamilyFamiliesIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create Family
 */
export const createFamilyFamiliesRegisterPost = (
    familyCreate: FamilyCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FamilyResponse>> => {
    
    
    return api.post(
      `/families/register`,
      familyCreate,options
    );
  }



export const getCreateFamilyFamiliesRegisterPostMutationOptions = <TData = Awaited<ReturnType<typeof createFamilyFamiliesRegisterPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FamilyCreate}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['createFamilyFamiliesRegisterPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFamilyFamiliesRegisterPost>>, {data: FamilyCreate}> = (props) => {
          const {data} = props ?? {};

          return  createFamilyFamiliesRegisterPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FamilyCreate}, TContext>}

    export type CreateFamilyFamiliesRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof createFamilyFamiliesRegisterPost>>>
    export type CreateFamilyFamiliesRegisterPostMutationBody = FamilyCreate
    export type CreateFamilyFamiliesRegisterPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Family
 */
export const useCreateFamilyFamiliesRegisterPost = <TData = Awaited<ReturnType<typeof createFamilyFamiliesRegisterPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FamilyCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: FamilyCreate},
        TContext
      > => {

      const mutationOptions = getCreateFamilyFamiliesRegisterPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Reports By User Id
 */
export const getReportsByUserIdDriveReportsUsersUserIdGet = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReportResponse[]>> => {
    
    
    return api.get(
      `/drive_reports/users/${userId}`,options
    );
  }


export const getGetReportsByUserIdDriveReportsUsersUserIdGetQueryKey = (userId: number,) => {
    return [`/drive_reports/users/${userId}`] as const;
    }

    
export const getGetReportsByUserIdDriveReportsUsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getReportsByUserIdDriveReportsUsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(userId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReportsByUserIdDriveReportsUsersUserIdGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReportsByUserIdDriveReportsUsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReportsByUserIdDriveReportsUsersUserIdGet>>> = ({ signal }) => getReportsByUserIdDriveReportsUsersUserIdGet(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReportsByUserIdDriveReportsUsersUserIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetReportsByUserIdDriveReportsUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getReportsByUserIdDriveReportsUsersUserIdGet>>>
export type GetReportsByUserIdDriveReportsUsersUserIdGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Reports By User Id
 */

export function useGetReportsByUserIdDriveReportsUsersUserIdGet<TData = Awaited<ReturnType<typeof getReportsByUserIdDriveReportsUsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(
 userId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReportsByUserIdDriveReportsUsersUserIdGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetReportsByUserIdDriveReportsUsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Report
 */
export const createReportDriveReportsUsersUserIdPost = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReportResponse>> => {
    
    
    return api.post(
      `/drive_reports/users/${userId}`,undefined,options
    );
  }



export const getCreateReportDriveReportsUsersUserIdPostMutationOptions = <TData = Awaited<ReturnType<typeof createReportDriveReportsUsersUserIdPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{userId: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['createReportDriveReportsUsersUserIdPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReportDriveReportsUsersUserIdPost>>, {userId: number}> = (props) => {
          const {userId} = props ?? {};

          return  createReportDriveReportsUsersUserIdPost(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{userId: number}, TContext>}

    export type CreateReportDriveReportsUsersUserIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof createReportDriveReportsUsersUserIdPost>>>
    
    export type CreateReportDriveReportsUsersUserIdPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Report
 */
export const useCreateReportDriveReportsUsersUserIdPost = <TData = Awaited<ReturnType<typeof createReportDriveReportsUsersUserIdPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {userId: number},
        TContext
      > => {

      const mutationOptions = getCreateReportDriveReportsUsersUserIdPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Report
 */
export const getReportDriveReportsIdGet = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReportResponse>> => {
    
    
    return api.get(
      `/drive_reports/${id}`,options
    );
  }


export const getGetReportDriveReportsIdGetQueryKey = (id: number,) => {
    return [`/drive_reports/${id}`] as const;
    }

    
export const getGetReportDriveReportsIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getReportDriveReportsIdGet>>, TError = AxiosError<HTTPValidationError>>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReportDriveReportsIdGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReportDriveReportsIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReportDriveReportsIdGet>>> = ({ signal }) => getReportDriveReportsIdGet(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReportDriveReportsIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetReportDriveReportsIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getReportDriveReportsIdGet>>>
export type GetReportDriveReportsIdGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Report
 */

export function useGetReportDriveReportsIdGet<TData = Awaited<ReturnType<typeof getReportDriveReportsIdGet>>, TError = AxiosError<HTTPValidationError>>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReportDriveReportsIdGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetReportDriveReportsIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Sensor By User Id
 */
export const getSensorByUserIdDriveSensorsUsersUserIdGet = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SensorResponse>> => {
    
    
    return api.get(
      `/drive_sensors/users/${userId}`,options
    );
  }


export const getGetSensorByUserIdDriveSensorsUsersUserIdGetQueryKey = (userId: number,) => {
    return [`/drive_sensors/users/${userId}`] as const;
    }

    
export const getGetSensorByUserIdDriveSensorsUsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getSensorByUserIdDriveSensorsUsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(userId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSensorByUserIdDriveSensorsUsersUserIdGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSensorByUserIdDriveSensorsUsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSensorByUserIdDriveSensorsUsersUserIdGet>>> = ({ signal }) => getSensorByUserIdDriveSensorsUsersUserIdGet(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSensorByUserIdDriveSensorsUsersUserIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSensorByUserIdDriveSensorsUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSensorByUserIdDriveSensorsUsersUserIdGet>>>
export type GetSensorByUserIdDriveSensorsUsersUserIdGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Sensor By User Id
 */

export function useGetSensorByUserIdDriveSensorsUsersUserIdGet<TData = Awaited<ReturnType<typeof getSensorByUserIdDriveSensorsUsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(
 userId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSensorByUserIdDriveSensorsUsersUserIdGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSensorByUserIdDriveSensorsUsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Sensor
 */
export const createSensorDriveSensorsPost = (
    sensorBase: SensorBase, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SensorResponse>> => {
    
    
    return api.post(
      `/drive_sensors`,
      sensorBase,options
    );
  }



export const getCreateSensorDriveSensorsPostMutationOptions = <TData = Awaited<ReturnType<typeof createSensorDriveSensorsPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: SensorBase}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['createSensorDriveSensorsPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSensorDriveSensorsPost>>, {data: SensorBase}> = (props) => {
          const {data} = props ?? {};

          return  createSensorDriveSensorsPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: SensorBase}, TContext>}

    export type CreateSensorDriveSensorsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createSensorDriveSensorsPost>>>
    export type CreateSensorDriveSensorsPostMutationBody = SensorBase
    export type CreateSensorDriveSensorsPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Sensor
 */
export const useCreateSensorDriveSensorsPost = <TData = Awaited<ReturnType<typeof createSensorDriveSensorsPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: SensorBase}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: SensorBase},
        TContext
      > => {

      const mutationOptions = getCreateSensorDriveSensorsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Send Mail
 */
export const sendMailEmailSendPost = (
    emailSend: EmailSend, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return api.post(
      `/email/send`,
      emailSend,options
    );
  }



export const getSendMailEmailSendPostMutationOptions = <TData = Awaited<ReturnType<typeof sendMailEmailSendPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: EmailSend}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['sendMailEmailSendPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendMailEmailSendPost>>, {data: EmailSend}> = (props) => {
          const {data} = props ?? {};

          return  sendMailEmailSendPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: EmailSend}, TContext>}

    export type SendMailEmailSendPostMutationResult = NonNullable<Awaited<ReturnType<typeof sendMailEmailSendPost>>>
    export type SendMailEmailSendPostMutationBody = EmailSend
    export type SendMailEmailSendPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Send Mail
 */
export const useSendMailEmailSendPost = <TData = Awaited<ReturnType<typeof sendMailEmailSendPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: EmailSend}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: EmailSend},
        TContext
      > => {

      const mutationOptions = getSendMailEmailSendPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
