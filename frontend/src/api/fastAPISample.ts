/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * FastAPI Sample
 * OpenAPI spec version: 0.0.1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'

const api = axios.create({
  baseURL: 'http://localhost:8000',
});

export type GetInfoGet200 = {[key: string]: string};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface UserResponse {
  /**
   * „É¶„Éº„Ç∂„ÉºÂêç(50ÊñáÂ≠ó‰ª•‰∏ã)
   * @maxLength 50
   */
  userName: string;
  /**
   * Âπ¥ÈΩ¢(18Ê≠≥‰ª•‰∏ä100Ê≠≥‰ª•‰∏ã)
   * @minimum 18
   * @maximum 100
   */
  age: number;
  user_id: number;
}

export interface UserCreate {
  /**
   * „É¶„Éº„Ç∂„ÉºÂêç(50ÊñáÂ≠ó‰ª•‰∏ã)
   * @maxLength 50
   */
  userName: string;
  /**
   * Âπ¥ÈΩ¢(18Ê≠≥‰ª•‰∏ä100Ê≠≥‰ª•‰∏ã)
   * @minimum 18
   * @maximum 100
   */
  age: number;
  /**
   * „Éë„Çπ„ÉØ„Éº„Éâ(8ÊñáÂ≠ó‰ª•‰∏ä)
   * @minLength 8
   */
  password: string;
}

export interface Token {
  access_token: string;
  token_type: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type BodyLoginAccessTokenAuthLoginPostClientSecret = string | null;

export type BodyLoginAccessTokenAuthLoginPostClientId = string | null;

export type BodyLoginAccessTokenAuthLoginPostGrantType = string | null;

export interface BodyLoginAccessTokenAuthLoginPost {
  grant_type?: BodyLoginAccessTokenAuthLoginPostGrantType;
  username: string;
  password: string;
  scope?: string;
  client_id?: BodyLoginAccessTokenAuthLoginPostClientId;
  client_secret?: BodyLoginAccessTokenAuthLoginPostClientSecret;
}



type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;



/**
 * @summary Get Info
 */
export const getInfoGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetInfoGet200>> => {
    
    
    return api.get(
      `/`,options
    );
  }


export const getGetInfoGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getGetInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof getInfoGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInfoGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInfoGet>>> = ({ signal }) => getInfoGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInfoGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof getInfoGet>>>
export type GetInfoGetQueryError = AxiosError<unknown>


/**
 * @summary Get Info
 */

export function useGetInfoGet<TData = Awaited<ReturnType<typeof getInfoGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetInfoGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * OAuth2 compatible token login, get an access token for future requests.
 * @summary Login Access Token
 */
export const loginAccessTokenAuthLoginPost = (
    bodyLoginAccessTokenAuthLoginPost: BodyLoginAccessTokenAuthLoginPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Token>> => {
    
    const formUrlEncoded = new URLSearchParams();
if(bodyLoginAccessTokenAuthLoginPost.grant_type !== undefined && bodyLoginAccessTokenAuthLoginPost.grant_type !== null) {
 formUrlEncoded.append('grant_type', bodyLoginAccessTokenAuthLoginPost.grant_type)
 }
formUrlEncoded.append('username', bodyLoginAccessTokenAuthLoginPost.username)
formUrlEncoded.append('password', bodyLoginAccessTokenAuthLoginPost.password)
if(bodyLoginAccessTokenAuthLoginPost.scope !== undefined) {
 formUrlEncoded.append('scope', bodyLoginAccessTokenAuthLoginPost.scope)
 }
if(bodyLoginAccessTokenAuthLoginPost.client_id !== undefined && bodyLoginAccessTokenAuthLoginPost.client_id !== null) {
 formUrlEncoded.append('client_id', bodyLoginAccessTokenAuthLoginPost.client_id)
 }
if(bodyLoginAccessTokenAuthLoginPost.client_secret !== undefined && bodyLoginAccessTokenAuthLoginPost.client_secret !== null) {
 formUrlEncoded.append('client_secret', bodyLoginAccessTokenAuthLoginPost.client_secret)
 }

    return api.post(
      `/auth/login`,
      formUrlEncoded,options
    );
  }



export const getLoginAccessTokenAuthLoginPostMutationOptions = <TData = Awaited<ReturnType<typeof loginAccessTokenAuthLoginPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyLoginAccessTokenAuthLoginPost}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['loginAccessTokenAuthLoginPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginAccessTokenAuthLoginPost>>, {data: BodyLoginAccessTokenAuthLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  loginAccessTokenAuthLoginPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyLoginAccessTokenAuthLoginPost}, TContext>}

    export type LoginAccessTokenAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginAccessTokenAuthLoginPost>>>
    export type LoginAccessTokenAuthLoginPostMutationBody = BodyLoginAccessTokenAuthLoginPost
    export type LoginAccessTokenAuthLoginPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Login Access Token
 */
export const useLoginAccessTokenAuthLoginPost = <TData = Awaited<ReturnType<typeof loginAccessTokenAuthLoginPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyLoginAccessTokenAuthLoginPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: BodyLoginAccessTokenAuthLoginPost},
        TContext
      > => {

      const mutationOptions = getLoginAccessTokenAuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Users
 */
export const getUsersUsersGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse[]>> => {
    
    
    return api.get(
      `/users`,options
    );
  }


export const getGetUsersUsersGetQueryKey = () => {
    return [`/users`] as const;
    }

    
export const getGetUsersUsersGetQueryOptions = <TData = Awaited<ReturnType<typeof getUsersUsersGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersUsersGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersUsersGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersUsersGet>>> = ({ signal }) => getUsersUsersGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersUsersGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersUsersGet>>>
export type GetUsersUsersGetQueryError = AxiosError<unknown>


/**
 * @summary Get Users
 */

export function useGetUsersUsersGet<TData = Awaited<ReturnType<typeof getUsersUsersGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersUsersGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersUsersGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get User Me
 */
export const getUserMeUsersMeGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return api.get(
      `/users/me`,options
    );
  }


export const getGetUserMeUsersMeGetQueryKey = () => {
    return [`/users/me`] as const;
    }

    
export const getGetUserMeUsersMeGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserMeUsersMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserMeUsersMeGet>>> = ({ signal }) => getUserMeUsersMeGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserMeUsersMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserMeUsersMeGet>>>
export type GetUserMeUsersMeGetQueryError = AxiosError<unknown>


/**
 * @summary Get User Me
 */

export function useGetUserMeUsersMeGet<TData = Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserMeUsersMeGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserMeUsersMeGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get User
 */
export const getUserUsersIdGet = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return api.get(
      `/users/${id}`,options
    );
  }


export const getGetUserUsersIdGetQueryKey = (id: number,) => {
    return [`/users/${id}`] as const;
    }

    
export const getGetUserUsersIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserUsersIdGet>>, TError = AxiosError<HTTPValidationError>>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserUsersIdGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserUsersIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserUsersIdGet>>> = ({ signal }) => getUserUsersIdGet(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserUsersIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserUsersIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserUsersIdGet>>>
export type GetUserUsersIdGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get User
 */

export function useGetUserUsersIdGet<TData = Awaited<ReturnType<typeof getUserUsersIdGet>>, TError = AxiosError<HTTPValidationError>>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserUsersIdGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserUsersIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create User
 */
export const createUserUsersRegisterPost = (
    userCreate: UserCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return api.post(
      `/users/register`,
      userCreate,options
    );
  }



export const getCreateUserUsersRegisterPostMutationOptions = <TData = Awaited<ReturnType<typeof createUserUsersRegisterPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: UserCreate}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['createUserUsersRegisterPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserUsersRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  createUserUsersRegisterPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: UserCreate}, TContext>}

    export type CreateUserUsersRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof createUserUsersRegisterPost>>>
    export type CreateUserUsersRegisterPostMutationBody = UserCreate
    export type CreateUserUsersRegisterPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create User
 */
export const useCreateUserUsersRegisterPost = <TData = Awaited<ReturnType<typeof createUserUsersRegisterPost>>, TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: UserCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getCreateUserUsersRegisterPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
